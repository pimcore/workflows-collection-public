name: Create release

on:
  workflow_dispatch:
    inputs:
      commit_url:
        required: true
        type: string
        description: 'URL of commit for which release will be created'
      tag_name:
        required: true
        type: string
        description: 'The tag name of the release with leading v'
      release_type:
        description: 'Choose relase type'
        default: latest
        required: false
        type: choice
        options:
          - latest
          - prerelase
          - regular
      draft:
        description: 'Draft release'
        required: true
        default: false
        type: boolean
      autoChangelog:
        description: 'Auto generated release notes'
        required: true
        default: true
        type: boolean
      changeLog:
        description: 'Custom release notes'
        required: false
        type: string
      close_milestone:
        description: 'Milestone title to close in target repo after release (optional)'
        required: false
        type: string
      new_milestone:
        description: 'Milestone title to create in target repo after release (optional)'
        required: false
        type: string
      move_issues:
        description: 'Comma-separated issue numbers to move into new milestone (optional), e.g. 123,456'
        required: false
        type: string

env:
  COMMIT_URL:  ${{ inputs.commit_url }}
  TAG_NAME: ${{ inputs.tag_name }}
  RELEASE_TYPE: ${{ inputs.release_type }}
  DRAFT: ${{ inputs.draft }}
  AUTO_CHANGELOG: ${{ inputs.autoChangelog }}
  CHANGELOG: ${{ inputs.changeLog }}
  CLOSE_MILESTONE: ${{ inputs.close_milestone }}
  NEW_MILESTONE: ${{ inputs.new_milestone }}
  MOVE_ISSUES: ${{ inputs.move_issues }}

jobs:
  display-parameters:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      latest: ${{ steps.step1.outputs.latest }}
      prerelease: ${{ steps.step1.outputs.prerelease }}
      target_repo: ${{ steps.step1.outputs.repo_name }}
      commit_hash: ${{ steps.step1.outputs.commit_hash }}
    steps:
      - name: Display parameters
        id: step1
        shell: bash
        run: |
          set -euo pipefail

          # Normalize release_type (keep accepting "prerelase" input option)
          if [[ "${RELEASE_TYPE}" == "prerelase" ]]; then
            PRERELEASE=true
            LATEST=false
          elif [[ "${RELEASE_TYPE}" == "latest" ]]; then
            PRERELEASE=false
            LATEST=true
          elif [[ "${RELEASE_TYPE}" == "regular" ]]; then
            PRERELEASE=false
            LATEST=false
          else
            echo "Unsupported release_type: ${RELEASE_TYPE}" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          # Extract target repository and commit hash from commit URL
          TARGET_REPO=$(echo "${COMMIT_URL}" | awk -F'/' '{print $(NF-2)}')
          COMMIT_HASH=$(echo "${COMMIT_URL}" | awk -F'/' '{print $NF}')

          if [[ -z "${TARGET_REPO}" || -z "${COMMIT_HASH}" ]]; then
            echo "Failed to parse commit_url: ${COMMIT_URL}" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          # Set outputs
          echo "latest=${LATEST}" >> "$GITHUB_OUTPUT"
          echo "prerelease=${PRERELEASE}" >> "$GITHUB_OUTPUT"
          echo "repo_name=${TARGET_REPO}" >> "$GITHUB_OUTPUT"
          echo "commit_hash=${COMMIT_HASH}" >> "$GITHUB_OUTPUT"

          {
            echo "Target repository: ${TARGET_REPO}"
            echo "Commit hash: ${COMMIT_HASH}"
            echo "Tag name: ${TAG_NAME}"
            echo "Draft: ${DRAFT}"
            echo "Auto changelog: ${AUTO_CHANGELOG}"
            echo "Custom changelog provided: $([[ -n "${CHANGELOG}" ]] && echo yes || echo no)"
            echo "Release type: ${RELEASE_TYPE}"
            echo "Pre-release: ${PRERELEASE}"
            echo "Latest: ${LATEST}"
            echo "Commit url: ${COMMIT_URL}"
            echo "Close milestone: ${CLOSE_MILESTONE}"
            echo "New milestone: ${NEW_MILESTONE}"
            echo "Move issues: ${MOVE_ISSUES}"
          } >> "$GITHUB_STEP_SUMMARY"

  create-release:
    runs-on: ubuntu-latest
    environment: production
    permissions:
      contents: read
    needs: display-parameters
    env:
      COMMIT_HASH: ${{ needs.display-parameters.outputs.commit_hash }}
      TARGET_REPO: ${{ needs.display-parameters.outputs.target_repo }}
      LATEST: ${{ needs.display-parameters.outputs.latest }}
      PRERELEASE: ${{ needs.display-parameters.outputs.prerelease }}
      RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
    outputs:
      target_repo: ${{ needs.display-parameters.outputs.target_repo }}
      commit_hash: ${{ needs.display-parameters.outputs.commit_hash }}
    steps:
      - name: Check existence of commit hash and tag name in target repo
        shell: bash
        run: |
          set -euo pipefail

          # Check if commit hash exists in target repo
          CHECK_COMMIT_HASH=$(curl -s -o /dev/null -w "%{http_code}" --location \
            "https://api.github.com/repos/pimcore/${TARGET_REPO}/commits/${COMMIT_HASH}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${RELEASE_TOKEN}")

          if [[ "${CHECK_COMMIT_HASH}" -ne 200 ]]; then
            echo "Non existing commit hash: ${COMMIT_HASH}" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          # Check if tag name exists in target repo
          CHECK_TAG_NAME=$(curl -s -o /dev/null -w "%{http_code}" --location \
            "https://api.github.com/repos/pimcore/${TARGET_REPO}/git/refs/tags/${TAG_NAME}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${RELEASE_TOKEN}")

          if [[ "${CHECK_TAG_NAME}" -eq 200 ]]; then
            echo "Tag name already exists: ${TAG_NAME}" >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: Create a release in target repo
        shell: bash
        run: |
          set -euo pipefail

          # Remove leading v from tag name for release name
          RELEASE_NAME="${TAG_NAME#v}"

          # Handle auto-generated + custom notes properly
          FINAL_BODY="${CHANGELOG}"
          
          if [[ "${AUTO_CHANGELOG}" == "true" && -n "${CHANGELOG}" ]]; then
            # Generate notes first, then append custom notes
            GEN_RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST --location \
              "https://api.github.com/repos/pimcore/${TARGET_REPO}/releases/generate-notes" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${RELEASE_TOKEN}" \
              -d "$(jq -n --arg tag "${TAG_NAME}" --arg target "${COMMIT_HASH}" '{tag_name:$tag, target_commitish:$target}')")
            
            GEN_STATUS=$(echo "${GEN_RESPONSE}" | awk -F: '/HTTP_STATUS:/ {print $2}')
            
            if [[ "${GEN_STATUS}" -eq 200 ]]; then
              GEN_NOTES=$(echo "${GEN_RESPONSE}" | sed '\$d' | jq -r '.body // ""')
              FINAL_BODY="${GEN_NOTES}\n\n---\n\n${CHANGELOG}"
            else
              echo "⚠️ Warning: generate-notes API failed (HTTP ${GEN_STATUS}), falling back to custom notes only" >> "$GITHUB_STEP_SUMMARY"
              FINAL_BODY="${CHANGELOG}"
            fi
          fi

          # Use jq to safely build JSON (avoids breaking on quotes/newlines in CHANGELOG)
          if [[ -n "${FINAL_BODY}" ]]; then
            # Body provided, disable auto-generation
            REQ_BODY=$(jq -n \
              --arg target_commitish "${COMMIT_HASH}" \
              --arg name "${RELEASE_NAME}" \
              --arg tag_name "${TAG_NAME}" \
              --arg make_latest "${LATEST}" \
              --argjson draft "${DRAFT}" \
              --argjson prerelease "${PRERELEASE}" \
              --arg body "${FINAL_BODY}" \
              '{
                target_commitish: $target_commitish,
                name: $name,
                draft: $draft,
                make_latest: $make_latest,
                prerelease: $prerelease,
                tag_name: $tag_name,
                generate_release_notes: false,
                body: $body
              }')
          else
            # No body, let GitHub auto-generate if requested
            REQ_BODY=$(jq -n \
              --arg target_commitish "${COMMIT_HASH}" \
              --arg name "${RELEASE_NAME}" \
              --arg tag_name "${TAG_NAME}" \
              --arg make_latest "${LATEST}" \
              --argjson draft "${DRAFT}" \
              --argjson prerelease "${PRERELEASE}" \
              --argjson generate_release_notes "${AUTO_CHANGELOG}" \
              '{
                target_commitish: $target_commitish,
                name: $name,
                draft: $draft,
                make_latest: $make_latest,
                prerelease: $prerelease,
                tag_name: $tag_name,
                generate_release_notes: $generate_release_notes
              }')
          fi

          CREATE_RELEASE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -X POST --location \
            "https://api.github.com/repos/pimcore/${TARGET_REPO}/releases" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${RELEASE_TOKEN}" \
            -d "${REQ_BODY}")

          HTTP_STATUS=$(echo "${CREATE_RELEASE}" | awk -F: '/HTTP_STATUS:/ {print $2}')

          if [[ "${HTTP_STATUS}" -ne 201 ]]; then
            echo "Failed to create release. HTTP Response: ${HTTP_STATUS}" >> "$GITHUB_STEP_SUMMARY"
            echo "Response payload (truncated):" >> "$GITHUB_STEP_SUMMARY"
            echo "${CREATE_RELEASE}" | head -c 2000 >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "Please create release manually..." >> "$GITHUB_STEP_SUMMARY"
            exit 1
          else
            RELEASE_URL=$(echo "${CREATE_RELEASE}" | awk -F'"' '/"html_url":/ {print $4; exit}')
            echo "Release created successfully: ${RELEASE_URL}" >> "$GITHUB_STEP_SUMMARY"
          fi

  milestone-maintenance:
    name: Milestone maintenance
    runs-on: ubuntu-latest
    permissions:
      contents: read
    needs: create-release

    # Run only when at least one milestone-related input is provided
    if: ${{ needs.create-release.result == 'success' && (inputs.close_milestone != '' || inputs.new_milestone != '' || inputs.move_issues != '') }}

    env:
      TARGET_REPO: ${{ needs.create-release.outputs.target_repo }}

    steps:
      - name: Validate milestone inputs
        shell: bash
        run: |
          set -euo pipefail

          if [[ -n "${MOVE_ISSUES}" && -z "${NEW_MILESTONE}" ]]; then
            echo "move_issues was provided but new_milestone is empty. Refusing to move issues without a target milestone." >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: Close milestone (by title or number) if provided
        if: ${{ inputs.close_milestone != '' }}
        shell: bash
        env:
          RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          set -euo pipefail
          INPUT="${CLOSE_MILESTONE}"

          # Check if input is numeric (milestone number) or text (title)
          if [[ "${INPUT}" =~ ^[0-9]+$ ]]; then
            MS_NUMBER="${INPUT}"
            echo "Using milestone number: ${MS_NUMBER}" >> "$GITHUB_STEP_SUMMARY"
          else
            # Find milestone by title with pagination
            TITLE="${INPUT}"
            MS_NUMBER=""
            PAGE=1
            while [[ -z "${MS_NUMBER}" || "${MS_NUMBER}" == "null" ]]; do
              MILESTONES_JSON=$(curl -s --location \
                "https://api.github.com/repos/pimcore/${TARGET_REPO}/milestones?state=open&per_page=100&page=${PAGE}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${RELEASE_TOKEN}")

              # Check if we got empty results (no more pages)
              if [[ "$(echo "${MILESTONES_JSON}" | jq '. | length')" -eq 0 ]]; then
                echo "Milestone to close not found (open) by title: ${TITLE}" >> "$GITHUB_STEP_SUMMARY"
                exit 1
              fi

              MS_NUMBER=$(echo "${MILESTONES_JSON}" | jq -r --arg t "${TITLE}" '.[] | select(.title == $t) | .number' | head -n 1)
              PAGE=$((PAGE + 1))

              # Safety limit to prevent infinite loops
              if [[ ${PAGE} -gt 20 ]]; then
                echo "Milestone search exceeded 2000 milestones. Title not found: ${TITLE}" >> "$GITHUB_STEP_SUMMARY"
                exit 1
              fi
            done
          fi

          curl -s --fail-with-body -X PATCH --location \
            "https://api.github.com/repos/pimcore/${TARGET_REPO}/milestones/${MS_NUMBER}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${RELEASE_TOKEN}" \
            -d "$(jq -n '{state:"closed"}')" >/dev/null

          echo "Closed milestone '${INPUT}' (number: ${MS_NUMBER})" >> "$GITHUB_STEP_SUMMARY"

      - name: Create new milestone (by title or number) if provided (reuse if exists)
        id: create_ms
        if: ${{ inputs.new_milestone != '' }}
        shell: bash
        env:
          RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          set -euo pipefail
          INPUT="${NEW_MILESTONE}"

          # Check if input is numeric (milestone number to reuse) or text (title to create)
          if [[ "${INPUT}" =~ ^[0-9]+$ ]]; then
            MS_NUMBER="${INPUT}"
            echo "Using existing milestone number: ${MS_NUMBER}" >> "$GITHUB_STEP_SUMMARY"
            echo "milestone_number=${MS_NUMBER}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          TITLE="${INPUT}"

          # Check if milestone already exists (open or closed) with pagination
          EXISTING_NUMBER=""
          PAGE=1
          while [[ -z "${EXISTING_NUMBER}" || "${EXISTING_NUMBER}" == "null" ]]; do
            EXISTING_JSON=$(curl -s --location \
              "https://api.github.com/repos/pimcore/${TARGET_REPO}/milestones?state=all&per_page=100&page=${PAGE}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${RELEASE_TOKEN}")

            # Check if we got empty results (no more pages)
            if [[ "$(echo "${EXISTING_JSON}" | jq '. | length')" -eq 0 ]]; then
              break
            fi

            EXISTING_NUMBER=$(echo "${EXISTING_JSON}" | jq -r --arg t "${TITLE}" '.[] | select(.title == $t) | .number' | head -n 1)
            
            if [[ -n "${EXISTING_NUMBER}" && "${EXISTING_NUMBER}" != "null" ]]; then
              echo "Milestone already exists '${TITLE}' (number: ${EXISTING_NUMBER}); reusing it." >> "$GITHUB_STEP_SUMMARY"
              echo "milestone_number=${EXISTING_NUMBER}" >> "$GITHUB_OUTPUT"
              exit 0
            fi

            PAGE=$((PAGE + 1))

            # Safety limit
            if [[ ${PAGE} -gt 20 ]]; then
              break
            fi
          done

          # Create new milestone if not found
          CREATED_JSON=$(curl -s --fail-with-body -X POST --location \
            "https://api.github.com/repos/pimcore/${TARGET_REPO}/milestones" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${RELEASE_TOKEN}" \
            -d "$(jq -n --arg t "${TITLE}" '{title:$t}')" )

          NEW_NUMBER=$(echo "${CREATED_JSON}" | jq -r '.number')
          if [[ -z "${NEW_NUMBER}" || "${NEW_NUMBER}" == "null" ]]; then
            echo "Failed to create milestone '${TITLE}'. Response:" >> "$GITHUB_STEP_SUMMARY"
            echo "${CREATED_JSON}" | head -c 2000 >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          echo "Created milestone '${TITLE}' (number: ${NEW_NUMBER})" >> "$GITHUB_STEP_SUMMARY"
          echo "milestone_number=${NEW_NUMBER}" >> "$GITHUB_OUTPUT"

      - name: Move specific issues into the new milestone
        if: ${{ inputs.move_issues != '' && inputs.new_milestone != '' }}
        shell: bash
        env:
          RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          set -euo pipefail

          MS_NUMBER="${{ steps.create_ms.outputs.milestone_number }}"
          if [[ -z "${MS_NUMBER}" ]]; then
            echo "No milestone number available; cannot move issues." >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

          # Normalize and iterate issue numbers
          IFS=',' read -ra ISSUES <<< "${MOVE_ISSUES}"
          MOVED_COUNT=0
          FAILED_COUNT=0

          for raw in "${ISSUES[@]}"; do
            ISSUE="$(echo "${raw}" | xargs)"
            [[ -z "${ISSUE}" ]] && continue

            # Verify issue exists before attempting to move
            CHECK_ISSUE=$(curl -s -o /dev/null -w "%{http_code}" --location \
              "https://api.github.com/repos/pimcore/${TARGET_REPO}/issues/${ISSUE}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${RELEASE_TOKEN}")

            if [[ "${CHECK_ISSUE}" -ne 200 ]]; then
              echo "⚠️ Issue #${ISSUE} not found, skipping" >> "$GITHUB_STEP_SUMMARY"
              FAILED_COUNT=$((FAILED_COUNT+1))
              continue
            fi

            # PATCH issue to set milestone
            MOVE_RESULT=$(curl -s -o /dev/null -w "%{http_code}" -X PATCH --location \
              "https://api.github.com/repos/pimcore/${TARGET_REPO}/issues/${ISSUE}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${RELEASE_TOKEN}" \
              -d "$(jq -n --argjson m "${MS_NUMBER}" '{milestone:$m}')")

            if [[ "${MOVE_RESULT}" -eq 200 ]]; then
              echo "✓ Moved issue #${ISSUE} -> milestone ${MS_NUMBER}" >> "$GITHUB_STEP_SUMMARY"
              MOVED_COUNT=$((MOVED_COUNT+1))
            else
              echo "⚠️ Failed to move issue #${ISSUE} (HTTP ${MOVE_RESULT})" >> "$GITHUB_STEP_SUMMARY"
              FAILED_COUNT=$((FAILED_COUNT+1))
            fi
          done

          echo "---" >> "$GITHUB_STEP_SUMMARY"
          echo "**Summary:** ${MOVED_COUNT} moved, ${FAILED_COUNT} failed/skipped" >> "$GITHUB_STEP_SUMMARY"
